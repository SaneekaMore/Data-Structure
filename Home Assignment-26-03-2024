Problem Statement 1:  Consider a string consisting of left { and right curly brackets } only.
Write an efficient C++/ Java program that can count the length of the
longest valid substring present in this string. Also, discuss its time
Complexity.

Algorithm: 

Initialize maxLen to 0, left to 0, and right to 0.
Iterate over the characters of the input string from left to right:
If the current character is '{', increment left; otherwise, increment right.
If left equals right, update maxLen to the maximum of maxLen and 2 * right.
If right is greater than left, reset left and right to 0.
Reset left and right to 0.
Iterate over the characters of the input string from right to left:
If the current character is '{', increment left; otherwise, increment right.
If left equals right, update maxLen to the maximum of maxLen and 2 * left.
If left is greater than right, reset left and right to 0.
Return maxLen.

Source Code:  

public class LongestValidSubstring {
    public static int longestValidSubstring(String s) {
        int maxLen = 0;
        int left = 0, right = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '{') {
                left++;
            } else {
                right++;
            }
            if (left == right) {
                maxLen = Math.max(maxLen, 2 * right);
            } else if (right > left) {
                left = right = 0;
            }
        }
        left = right = 0;
        for (int i = s.length() - 1; i >= 0; i--) {
            if (s.charAt(i) == '{') {
                left++;
            } else {
                right++;
            }
            if (left == right) {
                maxLen = Math.max(maxLen, 2 * left);
            } else if (left > right) {
                left = right = 0;
            }
        }
        return maxLen;
    }

    public static void main(String[] args) {
        String input = "{}{{}}{";
        System.out.println("Input string: " + input);
        System.out.println("Output: " + longestValidSubstring(input));
    }
}






Problem Statement 2:  Write a Program to generate 100 random numbers. As each number
is generated by inserting it into an initially empty binary search tree. When
all numbers have been inserted, print the level of leaf at the largest and
smallest level. Repeat the process 50 times. Print out the table with a
count of how many of the 50 runs resulted in the difference between
maximum and minimum leaf level 0, 1, 2, 3 and so on.

Algorithm: 

Repeat the process 50 times:
Initialize an empty binary search tree.
Generate 100 random numbers and insert them into the binary search tree.
Calculate and print the height of the tree (level of the leaf) at the largest and smallest levels.

Source Code:  

import java.util.Random;

public class RandomBST {
    public static class Node {
        int data;
        Node left, right;

        public Node(int item) {
            data = item;
            left = right = null;
        }
    }

    public static Node insert(Node root, int data) {
        if (root == null) {
            return new Node(data);
        }
        if (data < root.data) {
            root.left = insert(root.left, data);
        } else if (data > root.data) {
            root.right = insert(root.right, data);
        }
        return root;
    }

    public static int height(Node root) {
        if (root == null) {
            return 0;
        }
        int leftHeight = height(root.left);
        int rightHeight = height(root.right);
        return Math.max(leftHeight, rightHeight) + 1;
    }

    public static void main(String[] args) {
        int runs = 50;
        Random random = new Random();
        for (int i = 0; i < runs; i++) {
            Node root = null;
            for (int j = 0; j < 100; j++) {
                int num = random.nextInt(1000);
                root = insert(root, num);
            }
            int minLevel = height(root);
            int maxLevel = height(root);
            System.out.println("Run " + (i + 1) + ": Min Level = " + minLevel + ", Max Level = " + maxLevel);
        }
    }
}





Problem Statement 3:  Write a program that counts the number of leaves of a binary tree.
Use the binary search trees generated in Q2 to test your program.

Algorithm: 

Define a recursive function countLeaves that takes a node as input.
If the node is null, return 0.
If the node is a leaf (i.e., both left and right children are null), return 1.
Recursively call countLeaves on the left and right children of the node and return the sum of the results.

Source Code:  

public class BinaryTreeLeafCount {
    public static class Node {
        int data;
        Node left, right;

        public Node(int item) {
            data = item;
            left = right = null;
        }
    }

    public static int countLeaves(Node root) {
        if (root == null) {
            return 0;
        }
        if (root.left == null && root.right == null) {
            return 1;
        }
        return countLeaves(root.left) + countLeaves(root.right);
    }

    public static void main(String[] args) {
        Node root = new Node(1);
        root.left = new Node(2);
        root.right = new Node(3);
        root.left.left = new Node(4);
        root.left.right = new Node(5);
        root.right.left = new Node(6);
        root.right.right = new Node(7);

        System.out.println("Number of leaves: " + countLeaves(root));
    }
}
